\ completeness test of random generator
\ tests all 4G numbers generated by a 32b generator
\ needs 512 MB ram and a reasonable fast CPU - a Raspberry 3b+ needs at 22-25 minutes


536870912 allocate drop constant mybits \ allocate a 512 MB array giving 4G bits
create mypops 33 cells allot 			\ array to keep totals of all popcounts

hex : popcount ( number -- no_of_bits_in_number )
	dup 1 rshift 55555555 and -
	dup 33333333 and
	swap 2 rshift 33333333 and +
	dup 4 rshift +
	f0f0f0f and
	1010101 *
	18 rshift
; decimal

: 1bit()! ( u addr -- ) 				\ sets bit u in a bit-array starting at addr
	over 5 rshift cells + >r			\ convert u to pointer, add to array and put on r
	31 and 1 swap lshift				\ convert u to bitcounter and use to create mask
	r@ @ or r> ! ;						\ get value or with mask and save value

: zeropops mypops 33 0 fastfill ;

: .pops
	11 0 do cr
		3 0 do
			j 3* i + dup 3 .r ." =>"	\ ( 0-32!)
			4* mypops + @ 12 .r
		loop
	loop ;

: zerobits
	cr ." ..start clearing bits"
	mybits #mybytes 0 fill ;

: checkQ
	mybits #mybytes bounds do
		i @ popcount					\ ( count=0-31 )
		cells mypops +					\ ( addr in mypops )
		1+!								\ raise count by 1
	4 +loop ;

-- The random routine to be tested ------

0 value seed

hex : rndmreset ( -- ) 7a92764b to seed ; decimal

: testrndm ( -- u )
    seed
    dup 13 lshift xor
    dup 17 rshift xor
    dup 5  lshift xor
    dup to seed
    57947 *	;							\ this raises complexity between two consequtive numbers generated

-- End of test routine ------------------

: initsys zeropops rndmreset zerobits ;

: 128Mloop
	128 1024 * 1024 * 0 do
		testrndm mybits 1bit()!			\ << this is the test
	loop ;

: go
	initsys
	32 0 do
		cr ." ..loop " i 1+ . [char] / emit #bigloops .
		128Mloop
	loop
	checkQ .pops cr ;
